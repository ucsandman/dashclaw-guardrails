/**
 * Proof artifact generator
 * Converts test results into compliance-ready reports
 */

/**
 * Generate markdown proof report
 * @param {object} policyDoc - Policy document
 * @param {object} testResults - Jest test results (optional)
 * @returns {string} Markdown report
 */
export function generateMarkdownReport(policyDoc, testResults = null) {
  const { project, policies } = policyDoc;
  const timestamp = new Date().toISOString();
  
  let md = `# Guardrails Proof Report

**Project:** ${project || 'N/A'}  
**Generated:** ${timestamp}

---

## Summary

- **Total Policies:** ${policies.length}
- **Total Test Cases:** ${countTests(policies)}
`;

  if (testResults) {
    md += `- **Tests Passed:** ${testResults.numPassedTests || 0}/${testResults.numTotalTests || 0}
- **Status:** ${testResults.success ? '✅ PASS' : '❌ FAIL'}
`;
  }

  md += `\n---\n\n## Policies\n\n`;

  for (const policy of policies) {
    md += generatePolicySection(policy);
  }

  md += `\n---\n\n## Attestation

This report was auto-generated by \`guardrailgen\` and proves that the following guardrails are:
1. Defined in code (policy-as-code)
2. Tested with executable test cases
3. Enforced by deterministic evaluation logic

**How to verify:**
\`\`\`bash
cd generated-tests
npm install
npm test
\`\`\`

`;

  return md;
}

function countTests(policies) {
  return policies.reduce((sum, p) => sum + (p.tests?.length || 0), 0);
}

function generatePolicySection(policy) {
  const { id, description, applies_to, rule, tests } = policy;
  
  let section = `### Policy: \`${id}\`

**Description:** ${description}

**Applies to:**
${applies_to.tools.map(t => `- \`${t}\``).join('\n')}

**Rule:**
`;

  if (rule.block) {
    section += `- **Action:** BLOCK\n`;
    if (rule.allowlist && rule.allowlist.length > 0) {
      section += `- **Allowlist:** ${rule.allowlist.map(a => `\`${a}\``).join(', ')}\n`;
    }
  } else if (rule.require === 'approval') {
    section += `- **Action:** REQUIRE APPROVAL\n`;
  }

  section += `\n**Test Coverage:** ${tests?.length || 0} test case(s)\n`;
  
  if (tests && tests.length > 0) {
    section += `\n**Test Cases:**\n`;
    for (const test of tests) {
      section += `- ${test.name}: expects \`allowed=${test.expect.allowed}\`\n`;
    }
  }

  section += `\n`;
  return section;
}

/**
 * Generate JSON proof report (machine-readable)
 */
export function generateJsonReport(policyDoc, testResults = null) {
  const { project, policies } = policyDoc;
  
  return JSON.stringify({
    project,
    generated_at: new Date().toISOString(),
    summary: {
      total_policies: policies.length,
      total_tests: countTests(policies),
      test_results: testResults ? {
        passed: testResults.numPassedTests || 0,
        total: testResults.numTotalTests || 0,
        success: testResults.success
      } : null
    },
    policies: policies.map(p => ({
      id: p.id,
      description: p.description,
      applies_to: p.applies_to,
      rule: p.rule,
      test_count: p.tests?.length || 0
    }))
  }, null, 2);
}
